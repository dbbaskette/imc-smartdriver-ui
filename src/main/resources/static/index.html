<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMC Data Flow Demo</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #F9FAFB;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        .main-container {
            width: 100%;
            max-width: 1400px;
            text-align: center;
        }
        .container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        .pipeline-container {
            width: 66.66%;
            height: 540px;
            background-color: #1F2937;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #374151;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }
        .info-container {
            width: 33.33%;
            height: 540px;
            background-color: #1F2937;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #374151;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }
        .info-container h3 {
            color: #E5E7EB;
            margin: 0 0 15px 0;
            font-size: 1.2rem;
        }
        .info-content {
            color: #D1D5DB;
            font-size: 14px;
            line-height: 1.6;
        }
        h1 {
            font-size: 2.5rem;
            color: #E5E7EB;
            margin-bottom: 40px;
        }
        svg {
            width: 100%;
            height: 500px;
            border-radius: 12px;
            background-color: #1F2937;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .component {
            cursor: pointer;
        }
        .component.clickable-service {
            cursor: pointer;
        }
        .component.clickable-service:hover {
            opacity: 0.8;
        }
        .component.clickable-service:hover .component-icon {
            filter: drop-shadow(0 0 5px #34D399);
        }
        .component.clickable-service:hover .component-svg-icon {
            filter: drop-shadow(0 0 5px #34D399);
        }
        .component-icon {
            font-size: 48px;
            fill: #9CA3AF;
        }
        .component-svg-icon {
            filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.3));
        }
        .component-label {
            font-size: 14px;
            fill: #D1D5DB;
            font-weight: 500;
            text-anchor: middle;
        }
        .path {
            stroke: #4B5563;
            stroke-width: 2;
            stroke-dasharray: 5 5;
            fill: none;
        }
        .path-external-table {
            stroke: #8B5CF6; /* Purple 500 */
            stroke-width: 2;
            stroke-dasharray: 10 5;
            fill: none;
            opacity: 0.8;
        }
        .data-packet {
            fill: #34D399; /* Emerald 400 */
            stroke: #F9FAFB;
            stroke-width: 1.5;
            r: 7;
            filter: drop-shadow(0 0 5px #34D399);
        }
        .pxf-query {
            filter: drop-shadow(0 0 8px #4A90E2);
            opacity: 0.95;
        }
        
        /* Safe Driver Scoring Panel */
        .safe-driver-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 95%;
            max-width: 1200px;
            max-height: 90vh;
            background: linear-gradient(135deg, #1F2937 0%, #111827 100%);
            border: 2px solid #374151;
            border-radius: 16px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            border-bottom: 1px solid #374151;
            background: linear-gradient(90deg, #1F2937 0%, #374151 100%);
            border-radius: 14px 14px 0 0;
        }
        
        .panel-header h2 {
            color: #F9FAFB;
            margin: 0;
            font-size: 1.5rem;
            font-weight: 700;
        }
        
        .close-btn {
            background: none;
            border: none;
            color: #9CA3AF;
            font-size: 2rem;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .close-btn:hover {
            background: #374151;
            color: #F9FAFB;
        }
        
        .panel-content {
            padding: 30px;
        }
        
        .kpi-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .kpi-card {
            background: #374151;
            border: 1px solid #4B5563;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            transition: transform 0.2s;
        }
        
        .kpi-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        
        .kpi-card.alert {
            border-color: #EF4444;
            background: linear-gradient(135deg, #374151 0%, #4B1B1B 100%);
        }
        
        .kpi-icon {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .kpi-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #F9FAFB;
            margin-bottom: 5px;
        }
        
        .kpi-label {
            color: #D1D5DB;
            font-size: 0.9rem;
        }
        
        .description {
            background: #374151;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
            border-left: 4px solid #34D399;
        }
        
        .description p {
            color: #D1D5DB;
            margin: 0;
            line-height: 1.5;
            font-size: 0.9rem;
        }
        
        .feature-highlights {
            background: #374151;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
        }
        
        .feature-highlights h3 {
            color: #F9FAFB;
            margin: 0 0 10px 0;
            font-size: 1rem;
        }
        
        .feature-highlights ul {
            color: #D1D5DB;
            margin: 0;
            padding-left: 16px;
        }
        
        .feature-highlights li {
            margin-bottom: 4px;
            line-height: 1.4;
            font-size: 0.85rem;
        }
        
        .driver-tables {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
        }
        
        .driver-tables h3 {
            color: #F9FAFB;
            margin: 0 0 15px 0;
            font-size: 1.1rem;
        }
        
        .score-table {
            width: 100%;
            background: #374151;
            border-radius: 8px;
            overflow: hidden;
            border-collapse: collapse;
        }
        
        .score-table th {
            background: #4B5563;
            color: #F9FAFB;
            padding: 12px 8px;
            font-size: 0.85rem;
            font-weight: 600;
            text-align: left;
        }
        
        .score-table td {
            padding: 10px 8px;
            color: #D1D5DB;
            border-bottom: 1px solid #4B5563;
            font-size: 0.85rem;
        }
        
        .score-table tbody tr:hover {
            background: #4B5563;
        }
        
        .score-table .excellent {
            color: #10B981;
            font-weight: bold;
        }
        
        .score-table .high-risk {
            color: #EF4444;
            font-weight: bold;
        }
        
        .score-table .good {
            color: #22C55E;
            font-weight: bold;
        }
        
        .score-table .average {
            color: #EAB308;
            font-weight: bold;
        }
        
        .score-table .poor {
            color: #F59E0B;
            font-weight: bold;
        }
        
        .badge {
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .badge.excellent {
            background: #10B981;
            color: white;
        }
        
        .badge.good {
            background: #22C55E;
            color: white;
        }
        
        .badge.average {
            background: #EAB308;
            color: white;
        }
        
        .badge.poor {
            background: #F59E0B;
            color: white;
        }
        
        .badge.high-risk {
            background: #EF4444;
            color: white;
        }
        
        @media (max-width: 768px) {
            .driver-tables {
                grid-template-columns: 1fr;
            }
            .kpi-cards {
                grid-template-columns: 1fr;
            }
        }
        .queue-count {
            font-size: 24px;
            fill: #FBBF24; /* Amber 400 */
            font-weight: 700;
            text-anchor: middle;
        }
        .score-card {
            background-color: #1F2937;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            display: inline-block;
            border: 1px solid #374151;
        }
        .score-title {
            font-size: 1rem;
            color: #9CA3AF;
            margin: 0 0 10px 0;
        }
        .score-value {
            font-size: 3rem;
            fill: #34D399;
            font-weight: 700;
            margin: 0;
            transition: fill 0.5s;
        }
        .data-grid {
            fill: none;
            stroke: #374151;
            stroke-width: 1;
        }
        .data-grid-bg {
            fill: #1F2937;
            opacity: 0.9;
        }
        .data-grid-text {
            font-size: 8px;
            fill: #D1D5DB;
            text-anchor: middle;
            font-family: monospace;
        }
        .data-grid-value {
            font-size: 9px;
            fill: #34D399;
            text-anchor: middle;
            font-weight: 700;
            font-family: monospace;
        }
        .health-indicator {
            r: 6;
            stroke: #1F2937;
            stroke-width: 2;
            filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.3));
        }
        .health-indicator.healthy {
            fill: #10B981; /* Green */
        }
        .health-indicator.unhealthy {
            fill: #EF4444; /* Red */
        }
        .health-indicator.unknown {
            fill: #6B7280; /* Gray */
        }
        .component-tooltip {
            position: absolute;
            background-color: #111827;
            border: 1px solid #374151;
            border-radius: 6px;
            padding: 8px;
            font-size: 12px;
            color: #E5E7EB;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>

    <div class="main-container">
        <h1>IMC Vehicle Events Pipeline</h1>
        
        <div class="container">
            <div class="pipeline-container">
                <svg id="pipeline"></svg>
                
                <!-- Tooltip for component details -->
                <div id="tooltip" class="component-tooltip" style="display: none;"></div>
                
                <!-- Safe Driver Scoring Panel -->
                <div id="safe-driver-panel" class="safe-driver-panel" style="display: none;">
                    <div class="panel-header">
                        <h2>üõ°Ô∏è Safe Driver Scoring System</h2>
                        <button id="close-panel" class="close-btn">&times;</button>
                    </div>
                    <div class="panel-content">
                        <div class="scoring-overview">
                            <div class="kpi-cards">
                                <div class="kpi-card">
                                    <div class="kpi-icon">üõ°Ô∏è</div>
                                    <div class="kpi-value" id="fleet-score">83.2</div>
                                    <div class="kpi-label">Fleet Safety Score</div>
                                </div>
                                <div class="kpi-card alert">
                                    <div class="kpi-icon">üö®</div>
                                    <div class="kpi-value" id="high-risk-count">3</div>
                                    <div class="kpi-label">High Risk Drivers</div>
                                </div>
                                <div class="kpi-card">
                                    <div class="kpi-icon">üß†</div>
                                    <div class="kpi-value" id="ml-accuracy">94.3%</div>
                                    <div class="kpi-label">ML Model Accuracy</div>
                                </div>
                            </div>
                            
                            <div class="description">
                                <p><strong>Advanced Machine Learning System</strong> using MADlib on Greenplum to analyze real-time telemetry data and predict driver safety. The system combines <strong>supervised learning</strong> with business intelligence to generate actionable safety scores from 0-100.</p>
                            </div>
                            
                            <div class="feature-highlights">
                                <h3>üìä Key Features:</h3>
                                <ul>
                                    <li><strong>üö¶ Speed Compliance Analysis</strong> - Traffic violation monitoring (40% weight)</li>
                                    <li><strong>üèÅ G-Force Patterns</strong> - Driving smoothness assessment (25% weight)</li>
                                    <li><strong>‚ö° Harsh Event Detection</strong> - Aggressive behavior tracking (15% weight)</li>
                                    <li><strong>üì± Distraction Monitoring</strong> - Phone usage analysis (15% weight)</li>
                                    <li><strong>üìä Consistency Metrics</strong> - Speed variance analysis (5% weight)</li>
                                </ul>
                            </div>
                            
                            <div class="driver-tables">
                                <div class="top-performers">
                                    <h3>üèÜ Top Performers</h3>
                                    <table class="score-table">
                                        <thead>
                                            <tr><th>Driver</th><th>Score</th><th>Risk Level</th><th>Speed Compliance</th><th>Accidents</th></tr>
                                        </thead>
                                        <tbody id="top-drivers">
                                            <tr><td>400011</td><td class="excellent">93.89</td><td><span class="badge excellent">EXCELLENT</span></td><td>90.71%</td><td>0</td></tr>
                                            <tr><td>400017</td><td class="excellent">92.04</td><td><span class="badge excellent">EXCELLENT</span></td><td>90.52%</td><td>0</td></tr>
                                            <tr><td>400022</td><td class="excellent">91.15</td><td><span class="badge excellent">EXCELLENT</span></td><td>88.43%</td><td>0</td></tr>
                                            <tr><td>400035</td><td class="good">87.62</td><td><span class="badge good">GOOD</span></td><td>85.90%</td><td>0</td></tr>
                                            <tr><td>400019</td><td class="good">86.33</td><td><span class="badge good">GOOD</span></td><td>84.17%</td><td>0</td></tr>
                                        </tbody>
                                    </table>
                                </div>
                                
                                <div class="high-risk-drivers">
                                    <h3>‚ö†Ô∏è High Risk Drivers</h3>
                                    <table class="score-table">
                                        <thead>
                                            <tr><th>Driver</th><th>Score</th><th>Risk Level</th><th>Phone Usage</th><th>Accidents</th></tr>
                                        </thead>
                                        <tbody id="risk-drivers">
                                            <tr><td>400001</td><td class="high-risk">57.83</td><td><span class="badge high-risk">HIGH_RISK</span></td><td>26.25%</td><td>2</td></tr>
                                            <tr><td>400004</td><td class="poor">61.89</td><td><span class="badge poor">POOR</span></td><td>24.83%</td><td>1</td></tr>
                                            <tr><td>400008</td><td class="poor">59.42</td><td><span class="badge poor">POOR</span></td><td>28.91%</td><td>1</td></tr>
                                            <tr><td>400015</td><td class="average">65.77</td><td><span class="badge average">AVERAGE</span></td><td>22.15%</td><td>0</td></tr>
                                            <tr><td>400026</td><td class="average">63.84</td><td><span class="badge average">AVERAGE</span></td><td>31.72%</td><td>0</td></tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="score-card-container"></div>
            </div>
            
            <div class="info-container">
                <h3>Pipeline Metrics</h3>
                <div class="info-content">
                    <p><strong>Status:</strong> Active</p>
                    <p><strong>Uptime:</strong> 2h 34m</p>
                    <p><strong>Total Processed:</strong> 1.2M events</p>
                    <p><strong>Accidents Detected:</strong> 23</p>
                    <p><strong>HDFS Files:</strong> 892</p>
                    <p><strong>Database Rows:</strong> 45k</p>
                    
                    <div style="margin: 20px 0; border-top: 1px solid #374151; padding-top: 15px;">
                        <button id="resetMetricsBtn" onclick="resetMetrics()" style="
                            background-color: #DC2626; 
                            color: white; 
                            border: none; 
                            padding: 8px 16px; 
                            border-radius: 6px; 
                            cursor: pointer; 
                            font-size: 12px;
                            margin-right: 8px;
                        ">Reset Counters</button>
                        
                        <button id="clearResetBtn" onclick="clearReset()" style="
                            background-color: #6B7280; 
                            color: white; 
                            border: none; 
                            padding: 8px 16px; 
                            border-radius: 6px; 
                            cursor: pointer; 
                            font-size: 12px;
                            display: none;
                        ">Clear Reset</button>
                        
                        <div id="resetStatus" style="margin-top: 8px; font-size: 11px; color: #9CA3AF;"></div>
                    </div>
                    
                    <h4 style="color: #E5E7EB; margin: 20px 0 10px 0; font-size: 1rem;">Component Health</h4>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
                        <div style="margin: 2px 0;"><span id="health-status-generator">üî¥</span> Telemetry Generator</div>
                        <div style="margin: 2px 0;"><span id="health-status-exchange">üî¥</span> RabbitMQ Exchange</div>
                        <div style="margin: 2px 0;"><span id="health-status-hdfs">üî¥</span> HDFS Sink</div>
                        <div style="margin: 2px 0;">üü¢ Hadoop HDFS</div>
                        <div style="margin: 2px 0;"><span id="health-status-processor">üî¥</span> Events Processor</div>
                        <div style="margin: 2px 0;"><span id="health-status-jdbc">üî¥</span> JDBC Sink</div>
                        <div style="margin: 2px 0;">üü¢ Vehicle Events Queue</div>
                        <div style="margin: 2px 0;">üü¢ Greenplum Database</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const components = {
            generator:  { x: 100, y: 250, label: 'Telemetry Generator', icon: 'üöó', description: 'Vehicle data source' },
            exchange:   { x: 350, y: 250, label: 'telematics_exchange', svg: '/assets/RabbitMQ.svg', description: 'RabbitMQ fanout exchange' },
            hdfs:       { x: 600, y: 80, label: 'HDFS Sink', icon: 'üóÑÔ∏è', description: 'All data ‚Üí Parquet' },
            hadoop:     { x: 850, y: 80, label: 'Hadoop HDFS', svg: '/assets/hadoop.svg', description: 'File storage' },
            processor:  { x: 600, y: 250, label: 'Events Processor', icon: '‚öôÔ∏è', description: 'Processes telematics data for accident detection' },
            events:     { x: 850, y: 250, label: 'vehicle_events', svg: '/assets/RabbitMQ.svg', description: 'Vehicle events queue from processor' },
            database:   { x: 1100, y: 200, label: 'JDBC Sink', icon: 'üóÉÔ∏è', description: 'Persists events to database' },
            logsink:    { x: 1100, y: 380, label: 'Log Sink', icon: 'üìù', description: 'Outputs events to log files' },
            greenplum:  { x: 1300, y: 200, label: 'Greenplum', svg: '/assets/tanzu.png', description: 'Tanzu Greenplum Database' }
        };

        const paths = [
            { source: 'generator', target: 'exchange' },
            { source: 'exchange', target: 'hdfs' },
            { source: 'hdfs', target: 'hadoop' },
            { source: 'exchange', target: 'processor' },
            { source: 'processor', target: 'events' },
            { source: 'events', target: 'database' },
            { source: 'events', target: 'logsink' },
            { source: 'database', target: 'greenplum' },
            { source: 'hadoop', target: 'greenplum', type: 'external_table' }
        ];

        // --- D3 Setup ---
        const svg = d3.select("#pipeline");
        const width = svg.node().getBoundingClientRect().width;
        const height = svg.node().getBoundingClientRect().height;

        // Adjust positions based on actual SVG width
        Object.values(components).forEach(c => {
            c.x = (c.x / 1400) * width; // Layout spans 1400px with components ending at x:1300
        });

        // --- Render Components and Paths ---
        
        // Draw paths
        paths.forEach(p => {
            const source = components[p.source];
            const target = components[p.target];
            const pathClass = p.type === 'external_table' ? 'path-external-table' : 'path';
            
            let pathData;
            if (p.type === 'external_table') {
                // Route external table connection above JDBC Sink to avoid overlap
                const midX = (source.x + target.x) / 2;
                const controlY = Math.min(source.y, target.y) - 60; // Simpler arc 60px above
                pathData = `M${source.x},${source.y} Q${midX},${controlY} ${target.x},${target.y}`;
            } else {
                // Standard curve for regular paths  
                pathData = `M${source.x},${source.y} C${(source.x + target.x) / 2},${source.y} ${(source.x + target.x) / 2},${target.y} ${target.x},${target.y}`;
            }
            
            svg.append("path")
                .attr("class", pathClass)
                .attr("d", pathData);
        });

        // Draw components
        const componentGroups = svg.selectAll(".component")
            .data(Object.entries(components))
            .enter()
            .append("g")
            .attr("class", "component")
            .attr("transform", d => `translate(${d[1].x}, ${d[1].y})`);

        // Add component icons - SVG for components that have them, emoji for others
        componentGroups.each(function(d) {
            const group = d3.select(this);
            const data = d[1];
            
            if (data.svg) {
                // Use SVG logo
                group.append("image")
                    .attr("href", data.svg)
                    .attr("x", -24)
                    .attr("y", -49)
                    .attr("width", 48)
                    .attr("height", 48)
                    .attr("class", "component-svg-icon");
            } else {
                // Use emoji fallback
                group.append("text")
                    .attr("class", "component-icon")
                    .attr("y", -25)
                    .attr("text-anchor", "middle")
                    .text(data.icon);
            }
        });

        componentGroups.each(function(d, i) {
            const group = d3.select(this);
            const label = d[1].label;
            
            if (d[0] === 'generator') {
                // Stack "Telemetry" over "Generator" for space saving
                group.append("text")
                    .attr("class", "component-label")
                    .attr("y", 20)
                    .attr("text-anchor", "middle")
                    .text("Telemetry");
                group.append("text")
                    .attr("class", "component-label")
                    .attr("y", 32)
                    .attr("text-anchor", "middle")
                    .text("Generator");
            } else {
                // Single line label for other components
                group.append("text")
                    .attr("class", "component-label")
                    .attr("y", 25)
                    .attr("text-anchor", "middle")
                    .text(label);
            }
        });

        // Add health indicators for components with actuator endpoints
        const healthComponents = ['generator', 'exchange', 'processor', 'hdfs', 'database', 'logsink', 'events', 'greenplum']; // database maps to jdbc, events for vehicle_events queue
        componentGroups.each(function(d) {
            const componentId = d[0];
            if (healthComponents.includes(componentId)) {
                const group = d3.select(this);
                group.append("circle")
                    .attr("class", "health-indicator unknown")
                    .attr("id", `health-${componentId}`)
                    .attr("cx", 0)
                    .attr("cy", -75); // Consistent position above all icons
            }
        });

        // Add 2x2 data grids under each component
        componentGroups.each(function(d, i) {
            const group = d3.select(this);
            const gridData = generateMockData(d[0]); // Generate mock data based on component type
            
            // Grid background
            group.append("rect")
                .attr("class", "data-grid-bg")
                .attr("x", -75)
                .attr("y", 40)
                .attr("width", 150)
                .attr("height", 40)
                .attr("rx", 4);
            
            // Grid border
            group.append("rect")
                .attr("class", "data-grid")
                .attr("x", -75)
                .attr("y", 40)
                .attr("width", 150)
                .attr("height", 40)
                .attr("rx", 4);
            
            // Grid cells (2x2)
            const cellWidth = 75;
            const cellHeight = 20;
            
            gridData.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    const x = -75 + (colIndex * cellWidth);
                    const y = 40 + (rowIndex * cellHeight);
                    
                    // Cell separator lines
                    if (colIndex > 0) {
                        group.append("line")
                            .attr("class", "data-grid")
                            .attr("x1", x)
                            .attr("y1", 40)
                            .attr("x2", x)
                            .attr("y2", 80);
                    }
                    if (rowIndex > 0) {
                        group.append("line")
                            .attr("class", "data-grid")
                            .attr("x1", -75)
                            .attr("y1", y)
                            .attr("x2", 75)
                            .attr("y2", y);
                    }
                    
                    // Cell label
                    group.append("text")
                        .attr("class", "data-grid-text")
                        .attr("x", x + cellWidth/2)
                        .attr("y", y + 8)
                        .text(cell.label);
                    
                    // Cell value
                    group.append("text")
                        .attr("class", "data-grid-value")
                        .attr("x", x + cellWidth/2)
                        .attr("y", y + 16)
                        .text(cell.value);
                });
            });
        });

        // Add hover interactions
        componentGroups
            .on("mouseover", function(event, d) {
                const tooltip = document.getElementById('tooltip');
                let tooltipContent = `<strong>${d[1].label}</strong><br/>${d[1].description}`;
                
                // Add clickable indicator for generator
                if (d[0] === 'generator' && telemetryMetrics && telemetryMetrics.service_url) {
                    tooltipContent += `<br/><br/><em>Click to open service dashboard</em>`;
                    tooltipContent += `<br/>Service: ${telemetryMetrics.service_url}`;
                }
                
                // Add clickable indicator for exchange components
                if ((d[0] === 'exchange' || d[0] === 'events') && rabbitMQDashboardUrl) {
                    tooltipContent += `<br/><br/><em>Click to open RabbitMQ dashboard</em>`;
                }
                
                // Add queue information for vehicle_events
                if (d[0] === 'events' && vehicleEventsMetrics) {
                    tooltipContent += `<br/><br/><strong>Vehicle Events Queue:</strong>`;
                    const queueDepth = vehicleEventsMetrics.messages_in_queue || 0;
                    const totalMessages = vehicleEventsMetrics.total_messages || 0;
                    const publishRate = vehicleEventsMetrics.publish_rate || 0;
                    const deliveryRate = vehicleEventsMetrics.delivery_rate || 0;
                    
                    const totalFormatted = totalMessages > 1000 ? (totalMessages/1000).toFixed(1) + 'k' : totalMessages;
                    
                    tooltipContent += `<br/>‚Ä¢ Queue Depth: ${queueDepth} messages`;
                    tooltipContent += `<br/>‚Ä¢ Total Published: ${totalFormatted}`;
                    tooltipContent += `<br/>‚Ä¢ Publish Rate: ${publishRate.toFixed(1)}/s`;
                    tooltipContent += `<br/>‚Ä¢ Delivery Rate: ${deliveryRate.toFixed(1)}/s`;
                    tooltipContent += `<br/>‚Ä¢ Status: ${queueDepth > 0 ? 'Active' : 'Idle'}`;
                }
                
                // Add queue information for exchange
                if (d[0] === 'exchange' && exchangeQueueMetrics && exchangeQueueMetrics.queues) {
                    tooltipContent += `<br/><br/><strong>Exchange Summary:</strong>`;
                    if (exchangeMetrics) {
                        const inFormatted = exchangeMetrics.total_publish_in > 1000 ? (exchangeMetrics.total_publish_in/1000).toFixed(1) + 'k' : exchangeMetrics.total_publish_in;
                        const outFormatted = exchangeMetrics.total_publish_out > 1000 ? (exchangeMetrics.total_publish_out/1000).toFixed(1) + 'k' : exchangeMetrics.total_publish_out;
                        tooltipContent += `<br/>‚Ä¢ Messages In: ${inFormatted} (${(exchangeMetrics.current_rate_in || 0).toFixed(1)}/s)`;
                        tooltipContent += `<br/>‚Ä¢ Messages Out: ${outFormatted} (${(exchangeMetrics.current_rate_out || 0).toFixed(1)}/s)`;
                        tooltipContent += `<br/>‚Ä¢ Amplification: ${(exchangeMetrics.amplification_ratio || 0).toFixed(2)}x`;
                    }
                    tooltipContent += `<br/><br/><strong>Queue Details (${exchangeQueueMetrics.total_queues}):</strong>`;
                    exchangeQueueMetrics.queues.forEach(queue => {
                        const status = queue.messages > 0 ? 'active' : 'idle';
                        const publishedFormatted = queue.messages_published_to_queue > 1000 ? (queue.messages_published_to_queue/1000).toFixed(1) + 'k' : queue.messages_published_to_queue;
                        const deliveredFormatted = queue.messages_delivered > 1000 ? (queue.messages_delivered/1000).toFixed(1) + 'k' : queue.messages_delivered;
                        const queueShortName = queue.name.replace('telematics_exchange.', '');
                        tooltipContent += `<br/>‚Ä¢ <strong>${queueShortName}</strong>: ${queue.messages} pending`;
                        tooltipContent += `<br/>  ‚îî Published: ${publishedFormatted}, Delivered: ${deliveredFormatted}`;
                        tooltipContent += `<br/>  ‚îî Rates: ${(queue.publish_rate || 0).toFixed(1)}/s in, ${(queue.delivery_rate || 0).toFixed(1)}/s out`;
                    });
                }
                
                tooltip.innerHTML = tooltipContent;
                tooltip.style.display = 'block';
                tooltip.style.left = (event.pageX + 10) + 'px';
                tooltip.style.top = (event.pageY - 10) + 'px';
            })
            .on("mousemove", function(event) {
                const tooltip = document.getElementById('tooltip');
                tooltip.style.left = (event.pageX + 10) + 'px';
                tooltip.style.top = (event.pageY - 10) + 'px';
            })
            .on("mouseout", function() {
                document.getElementById('tooltip').style.display = 'none';
            })
            .on("click", function(event, d) {
                // Handle generator component click - open service URL
                if (d[0] === 'generator' && telemetryMetrics && telemetryMetrics.service_url) {
                    const serviceUrl = telemetryMetrics.service_url;
                    console.log('Opening telemetry generator service URL:', serviceUrl);
                    window.open(serviceUrl, '_blank');
                } 
                // Handle exchange components - open RabbitMQ management dashboard
                else if ((d[0] === 'exchange' || d[0] === 'events') && rabbitMQDashboardUrl) {
                    console.log('Opening RabbitMQ management dashboard:', rabbitMQDashboardUrl);
                    window.open(rabbitMQDashboardUrl, '_blank');
                }
                // Handle Greenplum - show Safe Driver Scoring panel
                else if (d[0] === 'greenplum') {
                    showSafeDriverScoringPanel();
                } 
                else {
                    alert(`Click details for ${d[1].label}\n\n${d[1].description}\n\n[Placeholder for detailed view]`);
                }
            });

        // Remove old queue count and score displays for cleaner vertical layout


        // --- Mock Data Generation ---
        function generateMockData(componentType) {
            const mockData = {
                generator: [
                    [{label: ' Msgs ', value: ''}, {label: '', value: '0'}],
                    [{label: ' Rate ', value: ''}, {label: '', value: '0.0/sec'}]
                ],
                exchange: [
                    [{label: ' In ', value: ''}, {label: '', value: '0.0/s'}],
                    [{label: ' Out ', value: ''}, {label: '', value: '0.0/s'}]
                ],
                hdfs: [
                    [{label: ' In ', value: ''}, {label: '', value: '0'}],
                    [{label: ' Files ', value: ''}, {label: '', value: '0'}]
                ],
                hadoop: [
                    [{label: 'Files', value: '892'}, {label: 'Size', value: '2.1GB'}],
                    [{label: 'Blocks', value: '1.8k'}, {label: 'Nodes', value: '3'}]
                ],
                processor: [
                    [{label: ' In ', value: ''}, {label: '', value: '0'}],
                    [{label: ' Events ', value: ''}, {label: '', value: '0'}]
                ],
                events: [
                    [{label: ' Queue ', value: ''}, {label: '', value: '0'}],
                    [{label: ' Total ', value: ''}, {label: '', value: '0'}]
                ],
                database: [
                    [{label: 'DB Inserts', value: ''}, {label: '', value: '0'}],
                    [{label: ' Errors ', value: ''}, {label: '', value: '0'}]
                ],
                logsink: [
                    [{label: ' Val1 ', value: ''}, {label: '', value: '123'}],
                    [{label: ' Val2 ', value: ''}, {label: '', value: '456'}]
                ],
                greenplum: [
                    [{label: 'Tables', value: '12'}, {label: 'Rows', value: '2.1M'}],
                    [{label: 'Size', value: '450MB'}, {label: 'Nodes', value: '3'}]
                ]
            };
            return mockData[componentType] || [
                [{label: 'Val1', value: '123'}, {label: 'Val2', value: '456'}],
                [{label: 'Val3', value: '789'}, {label: 'Val4', value: '0'}]
            ];
        }

        // --- Animation Logic ---
        let currentQueueSize = 0;
        let currentMetrics = null;
        let exchangeMetrics = null;
        let telemetryMetrics = null;
        let exchangeQueueMetrics = null;
        let rabbitMQHealth = null;
        let componentHealth = {
            generator: true,
            processor: true, 
            hdfs: true,
            jdbc: true,
            logsink: true,   // Add log sink health tracking  
            exchange: true,  // Add exchange health tracking
            events: true,    // Add events (vehicle_events queue) health tracking
            greenplum: true  // Add Greenplum health tracking
        };

        function animatePacket(pathId) {
            const pathDef = paths[pathId];
            
            // Use special PXF animation for external table connections
            if (pathDef.type === 'external_table') {
                animatePXFQuery(pathId);
                return;
            }
            
            // Check if both source and target components are healthy
            const sourceHealthy = isComponentHealthy(pathDef.source);
            const targetHealthy = isComponentHealthy(pathDef.target);
            
            if (!sourceHealthy || !targetHealthy) {
                // Skip animation if either component is unhealthy
                return;
            }
            
            const pathElement = svg.selectAll(".path").nodes()[pathId];
            const pathLength = pathElement.getTotalLength();
            
            const packet = svg.append("circle")
                .attr("class", "data-packet")
                .attr("r", 7)
                .attr("transform", `translate(${components[pathDef.source].x}, ${components[pathDef.source].y})`);

            packet.transition()
                .duration(2500 + Math.random() * 1000)
                .ease(d3.easeCubicInOut)
                .attrTween("transform", function(d) {
                    return function(t) {
                        const p = pathElement.getPointAtLength(t * pathLength);
                        return `translate(${p.x}, ${p.y})`;
                    }
                })
                .on("end", function() {
                    d3.select(this).remove();
                    
                    // Logic after packet reaches destination
                    if (pathDef.target === 'rabbit') {
                        currentQueueSize++;
                    }
                    if (pathDef.source === 'rabbit') {
                        currentQueueSize = Math.max(0, currentQueueSize - 1);
                    }
                    if (pathDef.target === 'score') {
                         updateDriverScore();
                    }
                })
                .remove();
        }
        
        // Special animation for PXF external table queries
        function animatePXFQuery(pathId) {
            const pathDef = paths[pathId];
            
            // Check if both source and target components are healthy
            const sourceHealthy = isComponentHealthy(pathDef.source);
            const targetHealthy = isComponentHealthy(pathDef.target);
            
            if (!sourceHealthy || !targetHealthy) {
                // Skip animation if either component is unhealthy
                return;
            }
            
            const pathElement = svg.selectAll(".path-external-table").nodes()[0]; // External table path
            if (!pathElement) return;
            
            const pathLength = pathElement.getTotalLength();
            
            // Create a group for the PXF icon
            const pxfGroup = svg.append("g")
                .attr("class", "pxf-query")
                .attr("transform", `translate(${components[pathDef.source].x}, ${components[pathDef.source].y})`);
            
            // Add small Greenplum-style background (hexagon-like shape)
            pxfGroup.append("circle")
                .attr("r", 12)
                .attr("fill", "#4A90E2") // Greenplum blue
                .attr("stroke", "#2E5C8A")
                .attr("stroke-width", 1.5)
                .attr("opacity", 0.9);
            
            // Add PXF text
            pxfGroup.append("text")
                .attr("text-anchor", "middle")
                .attr("dominant-baseline", "middle")
                .attr("font-family", "monospace")
                .attr("font-size", "8px")
                .attr("font-weight", "bold")
                .attr("fill", "white")
                .text("PXF");
            
            // Animate along the path
            pxfGroup.transition()
                .duration(4000 + Math.random() * 2000) // Slower than regular packets (SQL queries take time)
                .ease(d3.easeCubicInOut)
                .attrTween("transform", function(d) {
                    return function(t) {
                        const p = pathElement.getPointAtLength(t * pathLength);
                        return `translate(${p.x}, ${p.y})`;
                    }
                })
                .on("end", function() {
                    d3.select(this).remove();
                });
        }
        
        function updateDriverScore(score = null) {
            const newScore = score !== null ? Math.round(score) : Math.floor(75 + Math.random() * 25);
            // scoreValueText is not defined, so we'll skip this for now
            // This was likely from an old design that had a score display
            console.log('Driver score would be:', newScore);
        }

        // Fetch real metrics from API
        async function fetchMetrics() {
            try {
                const response = await fetch('/api/metrics');
                const metrics = await response.json();
                currentMetrics = metrics;
                
                // Update queue size with real data
                if (metrics.queue_depth >= 0) {
                    currentQueueSize = metrics.queue_depth;
                }
                
                // Update driver score with real data
                if (metrics.latest_score > 0) {
                    updateDriverScore(metrics.latest_score);
                }
                
                console.log('Metrics updated:', metrics);
                return metrics;
            } catch (error) {
                console.error('Failed to fetch metrics:', error);
                return null;
            }
        }

        // Queue display removed for cleaner UI

        // Global variables for component metrics
        let vehicleEventsMetrics = null;
        let eventsProcessorMetrics = null;
        let hdfsSinkMetrics = null;
        let jdbcSinkMetrics = null;
        let rabbitMQDashboardUrl = null;

        // Fetch exchange throughput data
        async function fetchExchangeThroughput() {
            try {
                const response = await fetch('/api/rabbitmq/exchange/throughput');
                const data = await response.json();
                exchangeMetrics = data;
                
                // These elements don't exist in current UI, so skip updating them
                // The exchange data is used elsewhere in the component grid
                console.log('Exchange throughput data:', data);
                
                console.log('Exchange throughput updated:', data);
                return data;
            } catch (error) {
                console.error('Failed to fetch exchange throughput:', error);
                return null;
            }
        }

        // Fetch component health status
        async function fetchComponentHealth() {
            try {
                const response = await fetch('/api/components/health');
                const data = await response.json();
                
                if (data.component_health) {
                    componentHealth = data.component_health;
                    
                    // Fetch Greenplum health separately
                    try {
                        const greenplumResponse = await fetch('/api/greenplum/health');
                        const greenplumData = await greenplumResponse.json();
                        if (greenplumData && typeof greenplumData.healthy === 'boolean') {
                            componentHealth.greenplum = greenplumData.healthy;
                            console.log('Greenplum health updated:', greenplumData.healthy);
                        }
                    } catch (greenplumError) {
                        console.warn('Failed to fetch Greenplum health:', greenplumError);
                        componentHealth.greenplum = false;
                    }
                    
                    updateHealthIndicators();
                    console.log('Component health updated:', componentHealth);
                }
                
                return data;
            } catch (error) {
                console.error('Failed to fetch component health:', error);
                return null;
            }
        }

        // Fetch telemetry generator publishing metrics
        async function fetchTelemetryMetrics() {
            try {
                const response = await fetch('/api/telemetry/generator/metrics');
                const data = await response.json();
                telemetryMetrics = data;
                
                // Update publishing metrics display
                updatePublishingMetrics(data);
                
                console.log('Telemetry generator metrics updated:', data);
                return data;
            } catch (error) {
                console.error('Failed to fetch telemetry generator metrics:', error);
                return null;
            }
        }

        // Update publishing metrics in UI
        function updatePublishingMetrics(metrics) {
            if (metrics && metrics.status !== 'error') {
                // Update generator grid with real metrics
                updateGeneratorGrid(metrics);
                
                // Add clickable class to generator if service URL is available
                if (metrics.service_url) {
                    const generatorComponent = document.querySelector('g.component:first-of-type');
                    if (generatorComponent) {
                        generatorComponent.classList.add('clickable-service');
                        console.log('Generator component now clickable with URL:', metrics.service_url);
                    }
                }
            }
        }
        
        // Update generator component grid with real telemetry metrics
        function updateGeneratorGrid(metrics) {
            if (!metrics || metrics.status === 'error') return;
            
            const messageRatePerSec = metrics.messages_rate_per_sec || 0;
            const totalMessages = metrics.messages_published_total || 0;
            
            console.log('Updating generator grid with:', totalMessages, messageRatePerSec);
            
            // Find generator grid cells - try multiple approaches
            let generatorGridValues = document.querySelectorAll('.component:first-child .data-grid-value');
            console.log('Found generator grid elements (approach 1):', generatorGridValues.length);
            
            if (generatorGridValues.length === 0) {
                // Try a more specific selector
                generatorGridValues = document.querySelectorAll('g.component:first-of-type .data-grid-value');
                console.log('Found generator grid elements (approach 2):', generatorGridValues.length);
            }
            
            if (generatorGridValues.length === 0) {
                // Try finding by position range
                const allGridValues = document.querySelectorAll('.data-grid-value');
                console.log('Total grid elements found:', allGridValues.length);
                
                // The generator should be the first component (leftmost)
                if (allGridValues.length >= 4) {
                    generatorGridValues = Array.from(allGridValues).slice(0, 4);
                    console.log('Using first 4 grid elements as generator grid');
                }
            }
            
            if (generatorGridValues.length >= 4) {
                // Format values
                const formattedMessages = totalMessages > 1000 ? (totalMessages/1000).toFixed(1) + 'k' : totalMessages;
                const formattedRate = messageRatePerSec.toFixed(1) + '/sec';
                
                // Row 1: Keep label as is, update value only
                // generatorGridValues[0] is already " Msgs " from mock data
                generatorGridValues[1].textContent = formattedMessages; // Value only
                
                // Row 2: Keep label as is, update value only
                // generatorGridValues[2] is already " Rate " from mock data
                generatorGridValues[3].textContent = formattedRate; // Value only
                
                console.log('Updated generator grid:', formattedMessages, formattedRate);
            } else {
                console.warn('Could not find generator grid elements. Selector returned:', generatorGridValues.length, 'elements');
            }
        }

        // Fetch telematics exchange queue metrics
        async function fetchExchangeQueueMetrics() {
            try {
                const response = await fetch('/api/telematics/exchange/queues');
                const data = await response.json();
                exchangeQueueMetrics = data;
                
                // Update exchange component grid with queue data
                updateExchangeGrid(data);
                
                console.log('Exchange queue metrics updated:', data);
                return data;
            } catch (error) {
                console.error('Failed to fetch exchange queue metrics:', error);
                return null;
            }
        }

        // Update exchange component grid with queue metrics
        function updateExchangeGrid(queueData) {
            // Use exchange throughput data if available, otherwise use queue data
            let exchangeData = exchangeMetrics || {};
            
            // Extract exchange throughput metrics
            const messagesIn = exchangeData.total_publish_in || 0;
            const messagesOut = exchangeData.total_publish_out || 0; 
            const rateIn = exchangeData.current_rate_in || 0;
            const rateOut = exchangeData.current_rate_out || 0;
            
            console.log('Updating exchange grid with:', messagesIn, 'in,', messagesOut, 'out,', rateIn, '/s in,', rateOut, '/s out');
            
            // Try same selector approaches as generator
            let exchangeGridValues = document.querySelectorAll('g.component:nth-of-type(2) .data-grid-value');
            console.log('Found exchange grid elements (approach 1):', exchangeGridValues.length);
            
            if (exchangeGridValues.length === 0) {
                // Try finding by approximate position (exchange is at x=350, scaled)
                const allGridValues = document.querySelectorAll('.data-grid-value');
                if (allGridValues.length >= 8) {
                    exchangeGridValues = Array.from(allGridValues).slice(4, 8); // Assume exchange is 2nd component
                    console.log('Using elements 4-8 as exchange grid');
                }
            }
            
            if (exchangeGridValues.length >= 4) {
                // Format values in same style as generator (key-value pairs)
                const formattedIn = messagesIn > 1000 ? (messagesIn/1000).toFixed(1) + 'k' : messagesIn;
                const formattedOut = messagesOut > 1000 ? (messagesOut/1000).toFixed(1) + 'k' : messagesOut;
                const formattedRateIn = rateIn.toFixed(1) + '/s';
                const formattedRateOut = rateOut.toFixed(1) + '/s';
                
                // Row 1: Keep label as is, update value only
                // exchangeGridValues[0] is already " In " from mock data
                exchangeGridValues[1].textContent = formattedIn;
                
                // Row 2: Keep label as is, update value only
                // exchangeGridValues[2] is already " Out " from mock data
                exchangeGridValues[3].textContent = formattedOut;
                
                console.log('Updated exchange grid:', formattedIn, 'in,', formattedOut, 'out');
            } else {
                console.warn('Could not find exchange grid elements. Found:', exchangeGridValues.length, 'elements');
            }
        }

        // Fetch vehicle events queue metrics
        async function fetchVehicleEventsMetrics() {
            try {
                const response = await fetch('/api/vehicle-events/queue/metrics');
                const data = await response.json();
                vehicleEventsMetrics = data;
                
                // Update vehicle events component grid
                updateVehicleEventsGrid(data);
                
                console.log('Vehicle events metrics updated:', data);
                return data;
            } catch (error) {
                console.error('Failed to fetch vehicle events metrics:', error);
                return null;
            }
        }

        // Fetch events processor metrics
        async function fetchEventsProcessorMetrics() {
            try {
                const response = await fetch('/api/events-processor/metrics');
                const data = await response.json();
                eventsProcessorMetrics = data;
                
                // Update events processor component grid
                updateEventsProcessorGrid(data);
                
                console.log('Events processor metrics updated:', data);
                return data;
            } catch (error) {
                console.error('Failed to fetch events processor metrics:', error);
                return null;
            }
        }

        // Fetch HDFS Sink metrics
        async function fetchHdfsSinkMetrics() {
            try {
                const response = await fetch('/api/hdfs-sink/metrics');
                const data = await response.json();
                hdfsSinkMetrics = data;
                
                // Update HDFS Sink component grid
                updateHdfsSinkGrid(data);
                
                console.log('HDFS Sink metrics updated:', data);
                return data;
            } catch (error) {
                console.error('Failed to fetch HDFS Sink metrics:', error);
                return null;
            }
        }

        // Fetch JDBC Sink metrics
        async function fetchJdbcSinkMetrics() {
            try {
                const response = await fetch('/api/jdbc-sink/metrics');
                const data = await response.json();
                jdbcSinkMetrics = data;
                
                // Update JDBC Sink component grid
                updateJdbcSinkGrid(data);
                
                console.log('JDBC Sink metrics updated:', data);
                return data;
            } catch (error) {
                console.error('Failed to fetch JDBC Sink metrics:', error);
                return null;
            }
        }

        // Fetch RabbitMQ management dashboard URL
        async function fetchRabbitMQDashboardInfo() {
            try {
                // Get the actual management URL from our backend
                const response = await fetch('/api/rabbitmq/management/url');
                const data = await response.json();
                
                if (data.status === 'available' && data.dashboard_url) {
                    rabbitMQDashboardUrl = data.dashboard_url;
                    console.log('RabbitMQ dashboard URL set to:', rabbitMQDashboardUrl);
                    
                    // Mark exchange components as clickable
                    markExchangeComponentsClickable();
                } else {
                    // Fallback to derived URL
                    rabbitMQDashboardUrl = deriveManagementUrl();
                    console.log('Using derived RabbitMQ dashboard URL:', rabbitMQDashboardUrl);
                    markExchangeComponentsClickable();
                }
                
                return data;
            } catch (error) {
                console.error('Failed to fetch RabbitMQ dashboard info:', error);
                // Use fallback URL
                rabbitMQDashboardUrl = deriveManagementUrl();
                markExchangeComponentsClickable();
                return null;
            }
        }

        // Derive RabbitMQ management dashboard URL
        function deriveManagementUrl() {
            // For Cloud Foundry or if we have a management API URL pattern
            // We'll try to construct it from known patterns
            
            // Option 1: Try localhost for local development
            if (window.location.hostname === 'localhost') {
                return 'http://localhost:15672';
            }
            
            // Option 2: For CF deployments, typically management console is available
            // We'll make a reasonable assumption based on the app URL
            const currentHost = window.location.hostname;
            
            // For CF, the management console might be available through a different route
            // This is a reasonable fallback - users can adjust if needed
            return `https://${currentHost.replace('imc-smartdriver-ui', 'rabbitmq-management')}/`;
        }

        // Mark exchange components as clickable
        function markExchangeComponentsClickable() {
            const exchangeComponent = document.querySelector('g.component:nth-of-type(2)'); // telematics_exchange
            const eventsComponent = document.querySelector('g.component:nth-of-type(6)'); // vehicle_events
            
            if (exchangeComponent) {
                exchangeComponent.classList.add('clickable-service');
                console.log('telematics_exchange component now clickable');
            }
            
            if (eventsComponent) {
                eventsComponent.classList.add('clickable-service');
                console.log('vehicle_events component now clickable');
            }
        }

        // Fetch RabbitMQ exchange health status
        async function fetchRabbitMQHealth() {
            try {
                const response = await fetch('/api/rabbitmq/exchange/health');
                const data = await response.json();
                rabbitMQHealth = data;
                
                // Update exchange and events health in component health object (both are RabbitMQ components)
                componentHealth.exchange = data.healthy;
                componentHealth.events = data.healthy; // vehicle_events queue shares same RabbitMQ health
                updateHealthIndicators();
                
                console.log('RabbitMQ health updated:', data);
                return data;
            } catch (error) {
                console.error('Failed to fetch RabbitMQ health:', error);
                componentHealth.exchange = false;
                componentHealth.events = false; // Both RabbitMQ components unhealthy
                updateHealthIndicators();
                return null;
            }
        }

        // Update vehicle events component grid
        function updateVehicleEventsGrid(data) {
            if (!data || data.status === 'error') return;
            
            const queueDepth = data.messages_in_queue || 0;
            const totalMessages = data.total_messages || 0;
            
            console.log('Updating vehicle events grid with queue:', queueDepth, 'total:', totalMessages);
            
            // Find vehicle events grid (it's the "events" component - around position 6)
            let eventsGridValues = document.querySelectorAll('g.component:nth-of-type(6) .data-grid-value');
            console.log('Found events grid elements (approach 1):', eventsGridValues.length);
            
            if (eventsGridValues.length === 0) {
                // Try finding by approximate position
                const allGridValues = document.querySelectorAll('.data-grid-value');
                if (allGridValues.length >= 24) { // 6 components * 4 values each
                    eventsGridValues = Array.from(allGridValues).slice(20, 24); // 6th component
                    console.log('Using elements 20-24 as events grid');
                }
            }
            
            if (eventsGridValues.length >= 4) {
                // Format values
                const formattedQueue = queueDepth > 1000 ? (queueDepth/1000).toFixed(1) + 'k' : queueDepth;
                const formattedTotal = totalMessages > 1000 ? (totalMessages/1000).toFixed(1) + 'k' : totalMessages;
                
                // Row 1: Keep label as is, update value only
                // eventsGridValues[0] is already " Queue " from mock data
                eventsGridValues[1].textContent = formattedQueue;
                
                // Row 2: Keep label as is, update value only
                // eventsGridValues[2] is already " Total " from mock data
                eventsGridValues[3].textContent = formattedTotal;
                
                console.log('Updated events grid:', formattedQueue, 'queue,', formattedTotal, 'total');
            } else {
                console.warn('Could not find vehicle events grid elements. Found:', eventsGridValues.length, 'elements');
            }
        }

        // Update events processor component grid
        function updateEventsProcessorGrid(data) {
            if (!data || data.status === 'error') return;
            
            const messagesIn = data.messages_in || 0;
            const messagesOut = data.messages_out || 0;
            const eventsCaptured = data.events_captured || 0;
            
            console.log('Updating events processor grid with in:', messagesIn, 'out:', messagesOut, 'events:', eventsCaptured);
            
            // Find events processor grid (it's the "processor" component - around position 5)
            let processorGridValues = document.querySelectorAll('g.component:nth-of-type(5) .data-grid-value');
            console.log('Found processor grid elements (approach 1):', processorGridValues.length);
            
            if (processorGridValues.length === 0) {
                // Try finding by approximate position
                const allGridValues = document.querySelectorAll('.data-grid-value');
                if (allGridValues.length >= 20) { // 5 components * 4 values each
                    processorGridValues = Array.from(allGridValues).slice(16, 20); // 5th component
                    console.log('Using elements 16-20 as processor grid');
                }
            }
            
            if (processorGridValues.length >= 4) {
                // Format values
                const formattedIn = messagesIn > 1000 ? (messagesIn/1000).toFixed(1) + 'k' : messagesIn;
                const formattedOut = messagesOut > 1000 ? (messagesOut/1000).toFixed(1) + 'k' : messagesOut;
                const formattedEvents = eventsCaptured > 1000 ? (eventsCaptured/1000).toFixed(1) + 'k' : eventsCaptured;
                
                // Row 1: Keep label as is, update value only
                // processorGridValues[0] is already " In " from mock data
                processorGridValues[1].textContent = formattedIn;
                
                // Row 2: Keep label as is, update value only
                // processorGridValues[2] is already " Events " from mock data
                processorGridValues[3].textContent = formattedEvents;
                
                console.log('Updated processor grid:', formattedIn, 'in,', formattedOut, 'out,', formattedEvents, 'events');
            } else {
                console.warn('Could not find events processor grid elements. Found:', processorGridValues.length, 'elements');
            }
        }

        // Update HDFS Sink component grid
        function updateHdfsSinkGrid(data) {
            if (!data || data.status === 'error') return;
            
            const messagesIn = data.messages_in || 0;
            const filesWritten = data.files_written || 0;
            
            console.log('Updating HDFS Sink grid with in:', messagesIn, 'files:', filesWritten);
            
            // Find HDFS Sink grid (it's the "hdfs" component - around position 3)
            let hdfsGridValues = document.querySelectorAll('g.component:nth-of-type(3) .data-grid-value');
            console.log('Found HDFS grid elements (approach 1):', hdfsGridValues.length);
            
            if (hdfsGridValues.length === 0) {
                // Try finding by approximate position
                const allGridValues = document.querySelectorAll('.data-grid-value');
                if (allGridValues.length >= 12) { // 3 components * 4 values each
                    hdfsGridValues = Array.from(allGridValues).slice(8, 12); // 3rd component
                    console.log('Using elements 8-12 as HDFS grid');
                }
            }
            
            if (hdfsGridValues.length >= 4) {
                // Format values
                const formattedIn = messagesIn > 1000 ? (messagesIn/1000).toFixed(1) + 'k' : messagesIn;
                const formattedFiles = filesWritten > 1000 ? (filesWritten/1000).toFixed(1) + 'k' : filesWritten;
                
                // Row 1: Keep label as is, update value only
                // hdfsGridValues[0] is already " In " from mock data
                hdfsGridValues[1].textContent = formattedIn;
                
                // Row 2: Keep label as is, update value only
                // hdfsGridValues[2] is already " Files " from mock data
                hdfsGridValues[3].textContent = formattedFiles;
                
                console.log('Updated HDFS grid:', formattedIn, 'in,', formattedFiles, 'files');
            } else {
                console.warn('Could not find HDFS Sink grid elements. Found:', hdfsGridValues.length, 'elements');
            }
        }

        // Update JDBC Sink component grid (database component)
        function updateJdbcSinkGrid(data) {
            if (!data || data.status === 'error') return;
            
            // Use the correct metric names from IMC JDBC Consumer
            const dbInserts = data.jdbc_consumer_messages_processed_total || 0;
            const messagesConsumed = data.rabbitmq_consumed_total || 0;
            const errors = Math.max(0, messagesConsumed - dbInserts); // Messages consumed but not processed = errors
            
            console.log('Updating JDBC Sink grid with DB inserts:', dbInserts, 'errors:', errors, '(consumed:', messagesConsumed, ')');
            
            // Find JDBC Sink grid (it's the "database" component - around position 7)
            let jdbcGridValues = document.querySelectorAll('g.component:nth-of-type(7) .data-grid-value');
            console.log('Found JDBC grid elements (approach 1):', jdbcGridValues.length);
            
            if (jdbcGridValues.length === 0) {
                // Try finding by approximate position
                const allGridValues = document.querySelectorAll('.data-grid-value');
                if (allGridValues.length >= 28) { // 7 components * 4 values each
                    jdbcGridValues = Array.from(allGridValues).slice(24, 28); // 7th component
                    console.log('Using elements 24-28 as JDBC grid');
                }
            }
            
            if (jdbcGridValues.length >= 4) {
                // Format values
                const formattedInserts = dbInserts > 1000 ? (dbInserts/1000).toFixed(1) + 'k' : dbInserts;
                const formattedErrors = errors > 1000 ? (errors/1000).toFixed(1) + 'k' : errors;
                
                // Row 1: Keep label as is, update value only
                // jdbcGridValues[0] is already "DB Inserts" from mock data
                jdbcGridValues[1].textContent = formattedInserts;
                
                // Row 2: Keep label as is, update value only
                // jdbcGridValues[2] is already " Errors " from mock data
                jdbcGridValues[3].textContent = formattedErrors;
                
                console.log('Updated JDBC grid:', formattedInserts, 'inserts,', formattedErrors, 'errors');
            } else {
                console.warn('Could not find JDBC Sink grid elements. Found:', jdbcGridValues.length, 'elements');
            }
        }

        // Update visual health indicators
        function updateHealthIndicators() {
            Object.keys(componentHealth).forEach(component => {
                // Map jdbc health to database component in UI
                const componentId = component === 'jdbc' ? 'database' : component;
                const healthCircle = document.getElementById(`health-${componentId}`);
                if (healthCircle) {
                    const isHealthy = componentHealth[component];
                    healthCircle.className.baseVal = `health-indicator ${isHealthy ? 'healthy' : 'unhealthy'}`;
                }
                
                // Update info panel status
                const statusElement = document.getElementById(`health-status-${component}`);
                if (statusElement) {
                    statusElement.textContent = componentHealth[component] ? 'üü¢' : 'üî¥';
                }
            });
        }

        // Check if a component is healthy for animation purposes
        function isComponentHealthy(componentName) {
            // Map component names to health tracking names
            const healthMap = {
                'generator': 'generator',
                'processor': 'processor', 
                'hdfs': 'hdfs',
                'database': 'jdbc',     // Map database component to jdbc health
                'exchange': 'exchange', // RabbitMQ exchange - now monitored
                'hadoop': true,         // Hadoop - always healthy for now  
                'events': 'events',     // RabbitMQ queue - now monitored
                'greenplum': true       // Greenplum - always healthy for now
            };
            
            const healthStatus = healthMap[componentName];
            return typeof healthStatus === 'boolean' ? healthStatus : componentHealth[healthStatus];
        }

        // Data grids are now integrated directly into the SVG components

        // --- Enhanced Animation with Flow Splitting ---
        let exchangeSplitToggle = false;
        let processorSplitToggle = false;

        // Path 0: generator ‚Üí exchange
        setInterval(() => animatePacket(0), 1000);

        // Exchange splits to HDFS and Processor alternately
        setInterval(() => {
            if (exchangeSplitToggle) {
                animatePacket(1); // exchange ‚Üí hdfs
            } else {
                animatePacket(3); // exchange ‚Üí processor
            }
            exchangeSplitToggle = !exchangeSplitToggle;
        }, 900);
        
        // Path 2: hdfs ‚Üí hadoop (file writes)
        setInterval(() => animatePacket(2), 1800);
        
        // Processor splits to Database and Events alternately
        setInterval(() => {
            if (processorSplitToggle) {
                animatePacket(4); // processor ‚Üí database
            } else {
                animatePacket(5); // processor ‚Üí vehicle_events
            }
            processorSplitToggle = !processorSplitToggle;
        }, 2400);

        // Path 6: hadoop ‚Üí greenplum (analytics)
        setInterval(() => animatePacket(6), 4000);
        
        // Path 7: database ‚Üí greenplum (processed data)
        setInterval(() => animatePacket(7), 3500);
        
        // Path 8: hadoop ‚Üí greenplum (PXF external table queries) - slower since these are analytical queries
        setInterval(() => animatePacket(8), 8000 + Math.random() * 4000);

        // Fetch metrics from API every 3 seconds
        setInterval(fetchMetrics, 3000);
        
        // Fetch exchange throughput every 2 seconds
        setInterval(fetchExchangeThroughput, 2000);
        
        // Fetch component health every 8 seconds (matches backend schedule)
        setInterval(fetchComponentHealth, 8000);
        
        // Fetch telemetry generator metrics every 5 seconds
        setInterval(fetchTelemetryMetrics, 5000);
        
        // --- Safe Driver Scoring Panel Functions ---
        function showSafeDriverScoringPanel() {
            document.getElementById('safe-driver-panel').style.display = 'block';
            // TODO: Fetch real data from Greenplum API endpoints
            console.log('Safe Driver Scoring panel opened');
        }
        
        function hideSafeDriverScoringPanel() {
            document.getElementById('safe-driver-panel').style.display = 'none';
        }
        
        // Close panel when clicking the X button
        document.addEventListener('DOMContentLoaded', function() {
            const closeBtn = document.getElementById('close-panel');
            if (closeBtn) {
                closeBtn.addEventListener('click', hideSafeDriverScoringPanel);
            }
            
            // Close panel when clicking outside of it
            document.addEventListener('click', function(event) {
                const panel = document.getElementById('safe-driver-panel');
                if (panel && panel.style.display === 'block' && !panel.contains(event.target)) {
                    // Only close if clicking outside and not on the Greenplum component
                    const greenplumComponent = event.target.closest('.component');
                    if (!greenplumComponent || !greenplumComponent.textContent.includes('Greenplum')) {
                        hideSafeDriverScoringPanel();
                    }
                }
            });
        });
        
        // Fetch exchange queue metrics every 6 seconds  
        setInterval(fetchExchangeQueueMetrics, 6000);
        
        // Fetch RabbitMQ health every 7 seconds
        setInterval(fetchRabbitMQHealth, 7000);
        
        // Fetch vehicle events metrics every 4 seconds  
        setInterval(fetchVehicleEventsMetrics, 4000);
        
        // Fetch events processor metrics every 5.5 seconds
        setInterval(fetchEventsProcessorMetrics, 5500);
        
        // Fetch HDFS Sink metrics every 6.5 seconds
        setInterval(fetchHdfsSinkMetrics, 6500);
        
        // Fetch JDBC Sink metrics every 7.5 seconds
        setInterval(fetchJdbcSinkMetrics, 7500);
        
        // Initial metrics fetch
        fetchMetrics();
        fetchExchangeThroughput();
        fetchComponentHealth();
        fetchTelemetryMetrics();
        fetchExchangeQueueMetrics();
        fetchRabbitMQHealth();
        fetchVehicleEventsMetrics();
        fetchEventsProcessorMetrics();
        fetchHdfsSinkMetrics();
        fetchJdbcSinkMetrics();
        fetchRabbitMQDashboardInfo();
        checkResetStatus();
        
        // Check reset status every 30 seconds
        setInterval(checkResetStatus, 30000);

        // --- Reset Functionality ---
        
        async function resetMetrics() {
            const resetBtn = document.getElementById('resetMetricsBtn');
            const clearBtn = document.getElementById('clearResetBtn');
            const statusDiv = document.getElementById('resetStatus');
            
            try {
                resetBtn.disabled = true;
                resetBtn.textContent = 'Resetting...';
                statusDiv.textContent = 'Capturing current values as baseline...';
                
                const response = await fetch('/api/metrics/reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    statusDiv.textContent = '‚úÖ Metrics reset! Counters now show values from this point.';
                    statusDiv.style.color = '#10B981';
                    clearBtn.style.display = 'inline-block';
                    resetBtn.textContent = 'Reset Again';
                    console.log('Metrics reset successful:', data);
                } else {
                    statusDiv.textContent = '‚ùå Reset failed: ' + data.message;
                    statusDiv.style.color = '#EF4444';
                }
                
            } catch (error) {
                console.error('Reset failed:', error);
                statusDiv.textContent = '‚ùå Reset failed: ' + error.message;
                statusDiv.style.color = '#EF4444';
                resetBtn.textContent = 'Reset Counters';
            }
            
            resetBtn.disabled = false;
        }
        
        async function clearReset() {
            const resetBtn = document.getElementById('resetMetricsBtn');
            const clearBtn = document.getElementById('clearResetBtn');
            const statusDiv = document.getElementById('resetStatus');
            
            try {
                clearBtn.disabled = true;
                clearBtn.textContent = 'Clearing...';
                statusDiv.textContent = 'Returning to original metrics...';
                
                const response = await fetch('/api/metrics/clear-reset', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    statusDiv.textContent = '‚úÖ Reset cleared! Showing original cumulative metrics.';
                    statusDiv.style.color = '#10B981';
                    clearBtn.style.display = 'none';
                    resetBtn.textContent = 'Reset Counters';
                    console.log('Reset cleared successfully:', data);
                } else {
                    statusDiv.textContent = '‚ùå Clear failed: ' + data.message;
                    statusDiv.style.color = '#EF4444';
                }
                
            } catch (error) {
                console.error('Clear reset failed:', error);
                statusDiv.textContent = '‚ùå Clear failed: ' + error.message;
                statusDiv.style.color = '#EF4444';
            }
            
            clearBtn.disabled = false;
            clearBtn.textContent = 'Clear Reset';
        }
        
        async function checkResetStatus() {
            try {
                const response = await fetch('/api/metrics/reset-status');
                const status = await response.json();
                
                const clearBtn = document.getElementById('clearResetBtn');
                const statusDiv = document.getElementById('resetStatus');
                
                if (status.baselines_captured) {
                    clearBtn.style.display = 'inline-block';
                    
                    if (status.time_since_reset_seconds) {
                        const timeSince = Math.floor(status.time_since_reset_seconds);
                        const minutes = Math.floor(timeSince / 60);
                        const seconds = timeSince % 60;
                        
                        if (minutes > 0) {
                            statusDiv.textContent = `üìä Metrics reset ${minutes}m ${seconds}s ago (${status.baseline_count} baselines)`;
                        } else {
                            statusDiv.textContent = `üìä Metrics reset ${seconds}s ago (${status.baseline_count} baselines)`;
                        }
                        statusDiv.style.color = '#9CA3AF';
                    }
                } else {
                    clearBtn.style.display = 'none';
                    if (statusDiv.textContent.includes('üìä')) {
                        statusDiv.textContent = '';
                    }
                }
                
            } catch (error) {
                console.debug('Failed to check reset status:', error);
            }
        }

    </script>
</body>
</html>
