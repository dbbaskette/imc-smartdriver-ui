<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IMC Data Flow Demo</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827;
            color: #F9FAFB;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        .main-container {
            width: 100%;
            max-width: 1400px;
            text-align: center;
        }
        .container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        .pipeline-container {
            width: 66.66%;
            height: 540px;
            background-color: #1F2937;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #374151;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }
        .info-container {
            width: 33.33%;
            height: 540px;
            background-color: #1F2937;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #374151;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            box-sizing: border-box;
        }
        .info-container h3 {
            color: #E5E7EB;
            margin: 0 0 15px 0;
            font-size: 1.2rem;
        }
        .info-content {
            color: #D1D5DB;
            font-size: 14px;
            line-height: 1.6;
        }
        h1 {
            font-size: 2.5rem;
            color: #E5E7EB;
            margin-bottom: 40px;
        }
        svg {
            width: 100%;
            height: 500px;
            border-radius: 12px;
            background-color: #1F2937;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .component {
            cursor: pointer;
        }
        .component.clickable-service {
            cursor: pointer;
        }
        .component.clickable-service:hover {
            opacity: 0.8;
        }
        .component.clickable-service:hover .component-icon {
            filter: drop-shadow(0 0 5px #34D399);
        }
        .component.clickable-service:hover .component-svg-icon {
            filter: drop-shadow(0 0 5px #34D399);
        }
        .component-icon {
            font-size: 48px;
            fill: #9CA3AF;
        }
        .component-svg-icon {
            filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.3));
        }
        .component-label {
            font-size: 14px;
            fill: #D1D5DB;
            font-weight: 500;
            text-anchor: middle;
        }
        .path {
            stroke: #4B5563;
            stroke-width: 2;
            stroke-dasharray: 5 5;
            fill: none;
        }
        .data-packet {
            fill: #34D399; /* Emerald 400 */
            stroke: #F9FAFB;
            stroke-width: 1.5;
            r: 7;
            filter: drop-shadow(0 0 5px #34D399);
        }
        .queue-count {
            font-size: 24px;
            fill: #FBBF24; /* Amber 400 */
            font-weight: 700;
            text-anchor: middle;
        }
        .score-card {
            background-color: #1F2937;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            display: inline-block;
            border: 1px solid #374151;
        }
        .score-title {
            font-size: 1rem;
            color: #9CA3AF;
            margin: 0 0 10px 0;
        }
        .score-value {
            font-size: 3rem;
            fill: #34D399;
            font-weight: 700;
            margin: 0;
            transition: fill 0.5s;
        }
        .data-grid {
            fill: none;
            stroke: #374151;
            stroke-width: 1;
        }
        .data-grid-bg {
            fill: #1F2937;
            opacity: 0.9;
        }
        .data-grid-text {
            font-size: 8px;
            fill: #D1D5DB;
            text-anchor: middle;
            font-family: monospace;
        }
        .data-grid-value {
            font-size: 9px;
            fill: #34D399;
            text-anchor: middle;
            font-weight: 700;
            font-family: monospace;
        }
        .health-indicator {
            r: 6;
            stroke: #1F2937;
            stroke-width: 2;
            filter: drop-shadow(0 0 3px rgba(0, 0, 0, 0.3));
        }
        .health-indicator.healthy {
            fill: #10B981; /* Green */
        }
        .health-indicator.unhealthy {
            fill: #EF4444; /* Red */
        }
        .health-indicator.unknown {
            fill: #6B7280; /* Gray */
        }
        .component-tooltip {
            position: absolute;
            background-color: #111827;
            border: 1px solid #374151;
            border-radius: 6px;
            padding: 8px;
            font-size: 12px;
            color: #E5E7EB;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>

    <div class="main-container">
        <h1>IMC Vehicle Events Pipeline</h1>
        
        <div class="container">
            <div class="pipeline-container">
                <svg id="pipeline"></svg>
                
                <!-- Tooltip for component details -->
                <div id="tooltip" class="component-tooltip" style="display: none;"></div>
                
                <div id="score-card-container"></div>
            </div>
            
            <div class="info-container">
                <h3>Pipeline Metrics</h3>
                <div class="info-content">
                    <p><strong>Status:</strong> Active</p>
                    <p><strong>Uptime:</strong> 2h 34m</p>
                    <p><strong>Total Processed:</strong> 1.2M events</p>
                    <p><strong>Accidents Detected:</strong> 23</p>
                    <p><strong>HDFS Files:</strong> 892</p>
                    <p><strong>Database Rows:</strong> 45k</p>
                    
                    <h4 style="color: #E5E7EB; margin: 20px 0 10px 0; font-size: 1rem;">Component Health</h4>
                    <div style="margin: 5px 0;"><span id="health-status-generator">🔴</span> Telemetry Generator</div>
                    
                    <div style="margin: 5px 0;"><span id="health-status-exchange">🔴</span> RabbitMQ Exchange</div>
                    <div style="margin: 5px 0;"><span id="health-status-hdfs">🔴</span> HDFS Sink</div>
                    <div style="margin: 5px 0;">🟢 Hadoop HDFS</div>
                    <div style="margin: 5px 0;"><span id="health-status-processor">🔴</span> Events Processor</div>
                    <div style="margin: 5px 0;"><span id="health-status-jdbc">🔴</span> JDBC Processor</div>
                    <div style="margin: 5px 0;">🟢 Vehicle Events Queue</div>
                    <div style="margin: 5px 0;">🟢 Greenplum Database</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration ---
        const components = {
            generator:  { x: 100, y: 250, label: 'Telemetry Generator', icon: '🚗', description: 'Vehicle data source' },
            exchange:   { x: 350, y: 250, label: 'telematics_exchange', svg: '/assets/RabbitMQ.svg', description: 'RabbitMQ fanout exchange' },
            hdfs:       { x: 600, y: 80, label: 'HDFS Sink', icon: '🗄️', description: 'All data → Parquet' },
            hadoop:     { x: 850, y: 80, label: 'Hadoop HDFS', svg: '/assets/hadoop.svg', description: 'File storage' },
            processor:  { x: 600, y: 350, label: 'Events Processor', icon: '⚙️', description: 'Accident detection' },
            database:   { x: 850, y: 250, label: 'JDBC Processor', icon: '🗃️', description: 'Database processor' },
            events:     { x: 850, y: 400, label: 'vehicle_events', svg: '/assets/RabbitMQ.svg', description: 'RabbitMQ queue' },
            greenplum:  { x: 1100, y: 250, label: 'Greenplum', svg: '/assets/tanzu.png', description: 'Tanzu Greenplum Database' }
        };

        const paths = [
            { source: 'generator', target: 'exchange' },
            { source: 'exchange', target: 'hdfs' },
            { source: 'hdfs', target: 'hadoop' },
            { source: 'exchange', target: 'processor' },
            { source: 'processor', target: 'database' },
            { source: 'processor', target: 'events' },
            { source: 'hadoop', target: 'greenplum' },
            { source: 'database', target: 'greenplum' }
        ];

        // --- D3 Setup ---
        const svg = d3.select("#pipeline");
        const width = svg.node().getBoundingClientRect().width;
        const height = svg.node().getBoundingClientRect().height;

        // Adjust positions based on actual SVG width
        Object.values(components).forEach(c => {
            c.x = (c.x / 1200) * width;
        });

        // --- Render Components and Paths ---
        
        // Draw paths
        paths.forEach(p => {
            const source = components[p.source];
            const target = components[p.target];
            svg.append("path")
                .attr("class", "path")
                .attr("d", `M${source.x},${source.y} C${(source.x + target.x) / 2},${source.y} ${(source.x + target.x) / 2},${target.y} ${target.x},${target.y}`);
        });

        // Draw components
        const componentGroups = svg.selectAll(".component")
            .data(Object.entries(components))
            .enter()
            .append("g")
            .attr("class", "component")
            .attr("transform", d => `translate(${d[1].x}, ${d[1].y})`);

        // Add component icons - SVG for components that have them, emoji for others
        componentGroups.each(function(d) {
            const group = d3.select(this);
            const data = d[1];
            
            if (data.svg) {
                // Use SVG logo
                group.append("image")
                    .attr("href", data.svg)
                    .attr("x", -24)
                    .attr("y", -49)
                    .attr("width", 48)
                    .attr("height", 48)
                    .attr("class", "component-svg-icon");
            } else {
                // Use emoji fallback
                group.append("text")
                    .attr("class", "component-icon")
                    .attr("y", -25)
                    .attr("text-anchor", "middle")
                    .text(data.icon);
            }
        });

        componentGroups.append("text")
            .attr("class", "component-label")
            .attr("y", 25)
            .text(d => d[1].label);

        // Add health indicators for components with actuator endpoints
        const healthComponents = ['generator', 'exchange', 'processor', 'hdfs', 'database']; // database maps to jdbc
        componentGroups.each(function(d) {
            const componentId = d[0];
            if (healthComponents.includes(componentId)) {
                const group = d3.select(this);
                group.append("circle")
                    .attr("class", "health-indicator unknown")
                    .attr("id", `health-${componentId}`)
                    .attr("cx", 0)
                    .attr("cy", -70); // Position above the icon
            }
        });

        // Add 2x2 data grids under each component
        componentGroups.each(function(d, i) {
            const group = d3.select(this);
            const gridData = generateMockData(d[0]); // Generate mock data based on component type
            
            // Grid background
            group.append("rect")
                .attr("class", "data-grid-bg")
                .attr("x", -60)
                .attr("y", 35)
                .attr("width", 120)
                .attr("height", 40)
                .attr("rx", 4);
            
            // Grid border
            group.append("rect")
                .attr("class", "data-grid")
                .attr("x", -60)
                .attr("y", 35)
                .attr("width", 120)
                .attr("height", 40)
                .attr("rx", 4);
            
            // Grid cells (2x2)
            const cellWidth = 60;
            const cellHeight = 20;
            
            gridData.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    const x = -60 + (colIndex * cellWidth);
                    const y = 35 + (rowIndex * cellHeight);
                    
                    // Cell separator lines
                    if (colIndex > 0) {
                        group.append("line")
                            .attr("class", "data-grid")
                            .attr("x1", x)
                            .attr("y1", 35)
                            .attr("x2", x)
                            .attr("y2", 75);
                    }
                    if (rowIndex > 0) {
                        group.append("line")
                            .attr("class", "data-grid")
                            .attr("x1", -60)
                            .attr("y1", y)
                            .attr("x2", 60)
                            .attr("y2", y);
                    }
                    
                    // Cell label
                    group.append("text")
                        .attr("class", "data-grid-text")
                        .attr("x", x + cellWidth/2)
                        .attr("y", y + 8)
                        .text(cell.label);
                    
                    // Cell value
                    group.append("text")
                        .attr("class", "data-grid-value")
                        .attr("x", x + cellWidth/2)
                        .attr("y", y + 16)
                        .text(cell.value);
                });
            });
        });

        // Add hover interactions
        componentGroups
            .on("mouseover", function(event, d) {
                const tooltip = document.getElementById('tooltip');
                let tooltipContent = `<strong>${d[1].label}</strong><br/>${d[1].description}`;
                
                // Add clickable indicator for generator
                if (d[0] === 'generator' && telemetryMetrics && telemetryMetrics.service_url) {
                    tooltipContent += `<br/><br/><em>Click to open service dashboard</em>`;
                    tooltipContent += `<br/>Service: ${telemetryMetrics.service_url}`;
                }
                
                // Add clickable indicator for exchange components
                if ((d[0] === 'exchange' || d[0] === 'events') && rabbitMQDashboardUrl) {
                    tooltipContent += `<br/><br/><em>Click to open RabbitMQ dashboard</em>`;
                }
                
                // Add queue information for exchange
                if (d[0] === 'exchange' && exchangeQueueMetrics && exchangeQueueMetrics.queues) {
                    tooltipContent += `<br/><br/><strong>Exchange Summary:</strong>`;
                    if (exchangeMetrics) {
                        const inFormatted = exchangeMetrics.total_publish_in > 1000 ? (exchangeMetrics.total_publish_in/1000).toFixed(1) + 'k' : exchangeMetrics.total_publish_in;
                        const outFormatted = exchangeMetrics.total_publish_out > 1000 ? (exchangeMetrics.total_publish_out/1000).toFixed(1) + 'k' : exchangeMetrics.total_publish_out;
                        tooltipContent += `<br/>• Messages In: ${inFormatted} (${(exchangeMetrics.current_rate_in || 0).toFixed(1)}/s)`;
                        tooltipContent += `<br/>• Messages Out: ${outFormatted} (${(exchangeMetrics.current_rate_out || 0).toFixed(1)}/s)`;
                        tooltipContent += `<br/>• Amplification: ${(exchangeMetrics.amplification_ratio || 0).toFixed(2)}x`;
                    }
                    tooltipContent += `<br/><br/><strong>Queue Details (${exchangeQueueMetrics.total_queues}):</strong>`;
                    exchangeQueueMetrics.queues.forEach(queue => {
                        const status = queue.messages > 0 ? 'active' : 'idle';
                        const publishedFormatted = queue.messages_published_to_queue > 1000 ? (queue.messages_published_to_queue/1000).toFixed(1) + 'k' : queue.messages_published_to_queue;
                        const deliveredFormatted = queue.messages_delivered > 1000 ? (queue.messages_delivered/1000).toFixed(1) + 'k' : queue.messages_delivered;
                        const queueShortName = queue.name.replace('telematics_exchange.', '');
                        tooltipContent += `<br/>• <strong>${queueShortName}</strong>: ${queue.messages} pending`;
                        tooltipContent += `<br/>  └ Published: ${publishedFormatted}, Delivered: ${deliveredFormatted}`;
                        tooltipContent += `<br/>  └ Rates: ${(queue.publish_rate || 0).toFixed(1)}/s in, ${(queue.delivery_rate || 0).toFixed(1)}/s out`;
                    });
                }
                
                tooltip.innerHTML = tooltipContent;
                tooltip.style.display = 'block';
                tooltip.style.left = (event.pageX + 10) + 'px';
                tooltip.style.top = (event.pageY - 10) + 'px';
            })
            .on("mousemove", function(event) {
                const tooltip = document.getElementById('tooltip');
                tooltip.style.left = (event.pageX + 10) + 'px';
                tooltip.style.top = (event.pageY - 10) + 'px';
            })
            .on("mouseout", function() {
                document.getElementById('tooltip').style.display = 'none';
            })
            .on("click", function(event, d) {
                // Handle generator component click - open service URL
                if (d[0] === 'generator' && telemetryMetrics && telemetryMetrics.service_url) {
                    const serviceUrl = telemetryMetrics.service_url;
                    console.log('Opening telemetry generator service URL:', serviceUrl);
                    window.open(serviceUrl, '_blank');
                } 
                // Handle exchange components - open RabbitMQ management dashboard
                else if ((d[0] === 'exchange' || d[0] === 'events') && rabbitMQDashboardUrl) {
                    console.log('Opening RabbitMQ management dashboard:', rabbitMQDashboardUrl);
                    window.open(rabbitMQDashboardUrl, '_blank');
                } 
                else {
                    alert(`Click details for ${d[1].label}\n\n${d[1].description}\n\n[Placeholder for detailed view]`);
                }
            });

        // Remove old queue count and score displays for cleaner vertical layout


        // --- Mock Data Generation ---
        function generateMockData(componentType) {
            const mockData = {
                generator: [
                    [{label: ' Msgs ', value: ' Msgs '}, {label: '', value: '0'}],
                    [{label: ' Rate ', value: ' Rate '}, {label: '', value: '0.0/sec'}]
                ],
                exchange: [
                    [{label: ' In ', value: '0'}, {label: '', value: '0.0/s'}],
                    [{label: ' Out ', value: '0'}, {label: '', value: '0.0/s'}]
                ],
                hdfs: [
                    [{label: 'Proc', value: '1.2k'}, {label: 'Files', value: '892'}],
                    [{label: 'Writers', value: '3'}, {label: 'Batch', value: '1000'}]
                ],
                hadoop: [
                    [{label: 'Files', value: '892'}, {label: 'Size', value: '2.1GB'}],
                    [{label: 'Blocks', value: '1.8k'}, {label: 'Nodes', value: '3'}]
                ],
                processor: [
                    [{label: ' In ', value: '0'}, {label: '', value: '0'}],
                    [{label: ' Accidents ', value: '0'}, {label: '', value: '0'}]
                ],
                events: [
                    [{label: ' Queue ', value: '0'}, {label: '', value: '0'}],
                    [{label: ' Total ', value: '0'}, {label: '', value: '0'}]
                ],
                database: [
                    [{label: 'Proc', value: '1.2k'}, {label: 'Rows', value: '45k'}],
                    [{label: 'Batch', value: '100'}, {label: 'Rate', value: '98%'}]
                ],
                greenplum: [
                    [{label: 'Tables', value: '12'}, {label: 'Rows', value: '2.1M'}],
                    [{label: 'Size', value: '450MB'}, {label: 'Nodes', value: '3'}]
                ]
            };
            return mockData[componentType] || [
                [{label: 'Val1', value: '123'}, {label: 'Val2', value: '456'}],
                [{label: 'Val3', value: '789'}, {label: 'Val4', value: '0'}]
            ];
        }

        // --- Animation Logic ---
        let currentQueueSize = 0;
        let currentMetrics = null;
        let exchangeMetrics = null;
        let telemetryMetrics = null;
        let exchangeQueueMetrics = null;
        let rabbitMQHealth = null;
        let componentHealth = {
            generator: true,
            processor: true, 
            hdfs: true,
            jdbc: true,
            exchange: true  // Add exchange health tracking
        };

        function animatePacket(pathId) {
            const pathDef = paths[pathId];
            
            // Check if both source and target components are healthy
            const sourceHealthy = isComponentHealthy(pathDef.source);
            const targetHealthy = isComponentHealthy(pathDef.target);
            
            if (!sourceHealthy || !targetHealthy) {
                // Skip animation if either component is unhealthy
                return;
            }
            
            const pathElement = svg.selectAll(".path").nodes()[pathId];
            const pathLength = pathElement.getTotalLength();
            
            const packet = svg.append("circle")
                .attr("class", "data-packet")
                .attr("r", 7)
                .attr("transform", `translate(${components[pathDef.source].x}, ${components[pathDef.source].y})`);

            packet.transition()
                .duration(2500 + Math.random() * 1000)
                .ease(d3.easeCubicInOut)
                .attrTween("transform", function(d) {
                    return function(t) {
                        const p = pathElement.getPointAtLength(t * pathLength);
                        return `translate(${p.x}, ${p.y})`;
                    }
                })
                .on("end", function() {
                    d3.select(this).remove();
                    
                    // Logic after packet reaches destination
                    if (pathDef.target === 'rabbit') {
                        currentQueueSize++;
                    }
                    if (pathDef.source === 'rabbit') {
                        currentQueueSize = Math.max(0, currentQueueSize - 1);
                    }
                    if (pathDef.target === 'score') {
                         updateDriverScore();
                    }
                })
                .remove();
        }
        
        function updateDriverScore(score = null) {
            const newScore = score !== null ? Math.round(score) : Math.floor(75 + Math.random() * 25);
            // scoreValueText is not defined, so we'll skip this for now
            // This was likely from an old design that had a score display
            console.log('Driver score would be:', newScore);
        }

        // Fetch real metrics from API
        async function fetchMetrics() {
            try {
                const response = await fetch('/api/metrics');
                const metrics = await response.json();
                currentMetrics = metrics;
                
                // Update queue size with real data
                if (metrics.queue_depth >= 0) {
                    currentQueueSize = metrics.queue_depth;
                }
                
                // Update driver score with real data
                if (metrics.latest_score > 0) {
                    updateDriverScore(metrics.latest_score);
                }
                
                console.log('Metrics updated:', metrics);
                return metrics;
            } catch (error) {
                console.error('Failed to fetch metrics:', error);
                return null;
            }
        }

        // Queue display removed for cleaner UI

        // Global variables for component metrics
        let vehicleEventsMetrics = null;
        let eventsProcessorMetrics = null;
        let rabbitMQDashboardUrl = null;

        // Fetch exchange throughput data
        async function fetchExchangeThroughput() {
            try {
                const response = await fetch('/api/rabbitmq/exchange/throughput');
                const data = await response.json();
                exchangeMetrics = data;
                
                // These elements don't exist in current UI, so skip updating them
                // The exchange data is used elsewhere in the component grid
                console.log('Exchange throughput data:', data);
                
                console.log('Exchange throughput updated:', data);
                return data;
            } catch (error) {
                console.error('Failed to fetch exchange throughput:', error);
                return null;
            }
        }

        // Fetch component health status
        async function fetchComponentHealth() {
            try {
                const response = await fetch('/api/components/health');
                const data = await response.json();
                
                if (data.component_health) {
                    componentHealth = data.component_health;
                    updateHealthIndicators();
                    console.log('Component health updated:', componentHealth);
                }
                
                return data;
            } catch (error) {
                console.error('Failed to fetch component health:', error);
                return null;
            }
        }

        // Fetch telemetry generator publishing metrics
        async function fetchTelemetryMetrics() {
            try {
                const response = await fetch('/api/telemetry/generator/metrics');
                const data = await response.json();
                telemetryMetrics = data;
                
                // Update publishing metrics display
                updatePublishingMetrics(data);
                
                console.log('Telemetry generator metrics updated:', data);
                return data;
            } catch (error) {
                console.error('Failed to fetch telemetry generator metrics:', error);
                return null;
            }
        }

        // Update publishing metrics in UI
        function updatePublishingMetrics(metrics) {
            if (metrics && metrics.status !== 'error') {
                // Update generator grid with real metrics
                updateGeneratorGrid(metrics);
                
                // Add clickable class to generator if service URL is available
                if (metrics.service_url) {
                    const generatorComponent = document.querySelector('g.component:first-of-type');
                    if (generatorComponent) {
                        generatorComponent.classList.add('clickable-service');
                        console.log('Generator component now clickable with URL:', metrics.service_url);
                    }
                }
            }
        }
        
        // Update generator component grid with real telemetry metrics
        function updateGeneratorGrid(metrics) {
            if (!metrics || metrics.status === 'error') return;
            
            const messageRatePerSec = metrics.messages_rate_per_sec || 0;
            const totalMessages = metrics.messages_published_total || 0;
            
            console.log('Updating generator grid with:', totalMessages, messageRatePerSec);
            
            // Find generator grid cells - try multiple approaches
            let generatorGridValues = document.querySelectorAll('.component:first-child .data-grid-value');
            console.log('Found generator grid elements (approach 1):', generatorGridValues.length);
            
            if (generatorGridValues.length === 0) {
                // Try a more specific selector
                generatorGridValues = document.querySelectorAll('g.component:first-of-type .data-grid-value');
                console.log('Found generator grid elements (approach 2):', generatorGridValues.length);
            }
            
            if (generatorGridValues.length === 0) {
                // Try finding by position range
                const allGridValues = document.querySelectorAll('.data-grid-value');
                console.log('Total grid elements found:', allGridValues.length);
                
                // The generator should be the first component (leftmost)
                if (allGridValues.length >= 4) {
                    generatorGridValues = Array.from(allGridValues).slice(0, 4);
                    console.log('Using first 4 grid elements as generator grid');
                }
            }
            
            if (generatorGridValues.length >= 4) {
                // Format values
                const formattedMessages = totalMessages > 1000 ? (totalMessages/1000).toFixed(1) + 'k' : totalMessages;
                const formattedRate = messageRatePerSec.toFixed(1) + '/sec';
                
                // Row 1: Label "Msgs" and Value
                generatorGridValues[0].textContent = ' Msgs '; // Label with spacing
                generatorGridValues[1].textContent = formattedMessages; // Value
                
                // Row 2: Label "Rate" and Value  
                generatorGridValues[2].textContent = ' Rate '; // Label with spacing
                generatorGridValues[3].textContent = formattedRate; // Value
                
                console.log('Updated generator grid:', formattedMessages, formattedRate);
            } else {
                console.warn('Could not find generator grid elements. Selector returned:', generatorGridValues.length, 'elements');
            }
        }

        // Fetch telematics exchange queue metrics
        async function fetchExchangeQueueMetrics() {
            try {
                const response = await fetch('/api/telematics/exchange/queues');
                const data = await response.json();
                exchangeQueueMetrics = data;
                
                // Update exchange component grid with queue data
                updateExchangeGrid(data);
                
                console.log('Exchange queue metrics updated:', data);
                return data;
            } catch (error) {
                console.error('Failed to fetch exchange queue metrics:', error);
                return null;
            }
        }

        // Update exchange component grid with queue metrics
        function updateExchangeGrid(queueData) {
            // Use exchange throughput data if available, otherwise use queue data
            let exchangeData = exchangeMetrics || {};
            
            // Extract exchange throughput metrics
            const messagesIn = exchangeData.total_publish_in || 0;
            const messagesOut = exchangeData.total_publish_out || 0; 
            const rateIn = exchangeData.current_rate_in || 0;
            const rateOut = exchangeData.current_rate_out || 0;
            
            console.log('Updating exchange grid with:', messagesIn, 'in,', messagesOut, 'out,', rateIn, '/s in,', rateOut, '/s out');
            
            // Try same selector approaches as generator
            let exchangeGridValues = document.querySelectorAll('g.component:nth-of-type(2) .data-grid-value');
            console.log('Found exchange grid elements (approach 1):', exchangeGridValues.length);
            
            if (exchangeGridValues.length === 0) {
                // Try finding by approximate position (exchange is at x=350, scaled)
                const allGridValues = document.querySelectorAll('.data-grid-value');
                if (allGridValues.length >= 8) {
                    exchangeGridValues = Array.from(allGridValues).slice(4, 8); // Assume exchange is 2nd component
                    console.log('Using elements 4-8 as exchange grid');
                }
            }
            
            if (exchangeGridValues.length >= 4) {
                // Format values in same style as generator (key-value pairs)
                const formattedIn = messagesIn > 1000 ? (messagesIn/1000).toFixed(1) + 'k' : messagesIn;
                const formattedOut = messagesOut > 1000 ? (messagesOut/1000).toFixed(1) + 'k' : messagesOut;
                const formattedRateIn = rateIn.toFixed(1) + '/s';
                const formattedRateOut = rateOut.toFixed(1) + '/s';
                
                // Row 1: Label " In " and Messages In Value
                exchangeGridValues[0].textContent = ' In ';
                exchangeGridValues[1].textContent = formattedIn;
                
                // Row 2: Label " Out " and Messages Out Value  
                exchangeGridValues[2].textContent = ' Out ';
                exchangeGridValues[3].textContent = formattedOut;
                
                console.log('Updated exchange grid:', formattedIn, 'in,', formattedOut, 'out');
            } else {
                console.warn('Could not find exchange grid elements. Found:', exchangeGridValues.length, 'elements');
            }
        }

        // Fetch vehicle events queue metrics
        async function fetchVehicleEventsMetrics() {
            try {
                const response = await fetch('/api/vehicle-events/queue/metrics');
                const data = await response.json();
                vehicleEventsMetrics = data;
                
                // Update vehicle events component grid
                updateVehicleEventsGrid(data);
                
                console.log('Vehicle events metrics updated:', data);
                return data;
            } catch (error) {
                console.error('Failed to fetch vehicle events metrics:', error);
                return null;
            }
        }

        // Fetch events processor metrics
        async function fetchEventsProcessorMetrics() {
            try {
                const response = await fetch('/api/events-processor/metrics');
                const data = await response.json();
                eventsProcessorMetrics = data;
                
                // Update events processor component grid
                updateEventsProcessorGrid(data);
                
                console.log('Events processor metrics updated:', data);
                return data;
            } catch (error) {
                console.error('Failed to fetch events processor metrics:', error);
                return null;
            }
        }

        // Fetch RabbitMQ management dashboard URL
        async function fetchRabbitMQDashboardInfo() {
            try {
                // Get the actual management URL from our backend
                const response = await fetch('/api/rabbitmq/management/url');
                const data = await response.json();
                
                if (data.status === 'available' && data.dashboard_url) {
                    rabbitMQDashboardUrl = data.dashboard_url;
                    console.log('RabbitMQ dashboard URL set to:', rabbitMQDashboardUrl);
                    
                    // Mark exchange components as clickable
                    markExchangeComponentsClickable();
                } else {
                    // Fallback to derived URL
                    rabbitMQDashboardUrl = deriveManagementUrl();
                    console.log('Using derived RabbitMQ dashboard URL:', rabbitMQDashboardUrl);
                    markExchangeComponentsClickable();
                }
                
                return data;
            } catch (error) {
                console.error('Failed to fetch RabbitMQ dashboard info:', error);
                // Use fallback URL
                rabbitMQDashboardUrl = deriveManagementUrl();
                markExchangeComponentsClickable();
                return null;
            }
        }

        // Derive RabbitMQ management dashboard URL
        function deriveManagementUrl() {
            // For Cloud Foundry or if we have a management API URL pattern
            // We'll try to construct it from known patterns
            
            // Option 1: Try localhost for local development
            if (window.location.hostname === 'localhost') {
                return 'http://localhost:15672';
            }
            
            // Option 2: For CF deployments, typically management console is available
            // We'll make a reasonable assumption based on the app URL
            const currentHost = window.location.hostname;
            
            // For CF, the management console might be available through a different route
            // This is a reasonable fallback - users can adjust if needed
            return `https://${currentHost.replace('imc-smartdriver-ui', 'rabbitmq-management')}/`;
        }

        // Mark exchange components as clickable
        function markExchangeComponentsClickable() {
            const exchangeComponent = document.querySelector('g.component:nth-of-type(2)'); // telematics_exchange
            const eventsComponent = document.querySelector('g.component:nth-of-type(6)'); // vehicle_events
            
            if (exchangeComponent) {
                exchangeComponent.classList.add('clickable-service');
                console.log('telematics_exchange component now clickable');
            }
            
            if (eventsComponent) {
                eventsComponent.classList.add('clickable-service');
                console.log('vehicle_events component now clickable');
            }
        }

        // Fetch RabbitMQ exchange health status
        async function fetchRabbitMQHealth() {
            try {
                const response = await fetch('/api/rabbitmq/exchange/health');
                const data = await response.json();
                rabbitMQHealth = data;
                
                // Update exchange health in component health object
                componentHealth.exchange = data.healthy;
                updateHealthIndicators();
                
                console.log('RabbitMQ health updated:', data);
                return data;
            } catch (error) {
                console.error('Failed to fetch RabbitMQ health:', error);
                componentHealth.exchange = false;
                updateHealthIndicators();
                return null;
            }
        }

        // Update vehicle events component grid
        function updateVehicleEventsGrid(data) {
            if (!data || data.status === 'error') return;
            
            const queueDepth = data.messages_in_queue || 0;
            const totalMessages = data.total_messages || 0;
            
            console.log('Updating vehicle events grid with queue:', queueDepth, 'total:', totalMessages);
            
            // Find vehicle events grid (it's the "events" component - around position 6)
            let eventsGridValues = document.querySelectorAll('g.component:nth-of-type(6) .data-grid-value');
            console.log('Found events grid elements (approach 1):', eventsGridValues.length);
            
            if (eventsGridValues.length === 0) {
                // Try finding by approximate position
                const allGridValues = document.querySelectorAll('.data-grid-value');
                if (allGridValues.length >= 24) { // 6 components * 4 values each
                    eventsGridValues = Array.from(allGridValues).slice(20, 24); // 6th component
                    console.log('Using elements 20-24 as events grid');
                }
            }
            
            if (eventsGridValues.length >= 4) {
                // Format values
                const formattedQueue = queueDepth > 1000 ? (queueDepth/1000).toFixed(1) + 'k' : queueDepth;
                const formattedTotal = totalMessages > 1000 ? (totalMessages/1000).toFixed(1) + 'k' : totalMessages;
                
                // Row 1: Label " Queue " and Queue Depth Value
                eventsGridValues[0].textContent = ' Queue ';
                eventsGridValues[1].textContent = formattedQueue;
                
                // Row 2: Label " Total " and Total Messages Value  
                eventsGridValues[2].textContent = ' Total ';
                eventsGridValues[3].textContent = formattedTotal;
                
                console.log('Updated events grid:', formattedQueue, 'queue,', formattedTotal, 'total');
            } else {
                console.warn('Could not find vehicle events grid elements. Found:', eventsGridValues.length, 'elements');
            }
        }

        // Update events processor component grid
        function updateEventsProcessorGrid(data) {
            if (!data || data.status === 'error') return;
            
            const messagesIn = data.messages_in || 0;
            const accidentsDetected = data.accidents_detected || 0;
            
            console.log('Updating events processor grid with in:', messagesIn, 'accidents:', accidentsDetected);
            
            // Find events processor grid (it's the "processor" component - around position 5)
            let processorGridValues = document.querySelectorAll('g.component:nth-of-type(5) .data-grid-value');
            console.log('Found processor grid elements (approach 1):', processorGridValues.length);
            
            if (processorGridValues.length === 0) {
                // Try finding by approximate position
                const allGridValues = document.querySelectorAll('.data-grid-value');
                if (allGridValues.length >= 20) { // 5 components * 4 values each
                    processorGridValues = Array.from(allGridValues).slice(16, 20); // 5th component
                    console.log('Using elements 16-20 as processor grid');
                }
            }
            
            if (processorGridValues.length >= 4) {
                // Format values
                const formattedIn = messagesIn > 1000 ? (messagesIn/1000).toFixed(1) + 'k' : messagesIn;
                const formattedAccidents = accidentsDetected > 1000 ? (accidentsDetected/1000).toFixed(1) + 'k' : accidentsDetected;
                
                // Row 1: Label " In " and Messages In Value
                processorGridValues[0].textContent = ' In ';
                processorGridValues[1].textContent = formattedIn;
                
                // Row 2: Label " Accidents " and Accidents Detected Value  
                processorGridValues[2].textContent = ' Accidents ';
                processorGridValues[3].textContent = formattedAccidents;
                
                console.log('Updated processor grid:', formattedIn, 'in,', formattedAccidents, 'accidents');
            } else {
                console.warn('Could not find events processor grid elements. Found:', processorGridValues.length, 'elements');
            }
        }

        // Update visual health indicators
        function updateHealthIndicators() {
            Object.keys(componentHealth).forEach(component => {
                // Map jdbc health to database component in UI
                const componentId = component === 'jdbc' ? 'database' : component;
                const healthCircle = document.getElementById(`health-${componentId}`);
                if (healthCircle) {
                    const isHealthy = componentHealth[component];
                    healthCircle.className.baseVal = `health-indicator ${isHealthy ? 'healthy' : 'unhealthy'}`;
                }
                
                // Update info panel status
                const statusElement = document.getElementById(`health-status-${component}`);
                if (statusElement) {
                    statusElement.textContent = componentHealth[component] ? '🟢' : '🔴';
                }
            });
        }

        // Check if a component is healthy for animation purposes
        function isComponentHealthy(componentName) {
            // Map component names to health tracking names
            const healthMap = {
                'generator': 'generator',
                'processor': 'processor', 
                'hdfs': 'hdfs',
                'database': 'jdbc',     // Map database component to jdbc health
                'exchange': 'exchange', // RabbitMQ exchange - now monitored
                'hadoop': true,         // Hadoop - always healthy for now  
                'events': true,         // RabbitMQ queue - always healthy for now
                'greenplum': true       // Greenplum - always healthy for now
            };
            
            const healthStatus = healthMap[componentName];
            return typeof healthStatus === 'boolean' ? healthStatus : componentHealth[healthStatus];
        }

        // Data grids are now integrated directly into the SVG components

        // --- Enhanced Animation with Flow Splitting ---
        let exchangeSplitToggle = false;
        let processorSplitToggle = false;

        // Path 0: generator → exchange
        setInterval(() => animatePacket(0), 1000);

        // Exchange splits to HDFS and Processor alternately
        setInterval(() => {
            if (exchangeSplitToggle) {
                animatePacket(1); // exchange → hdfs
            } else {
                animatePacket(3); // exchange → processor
            }
            exchangeSplitToggle = !exchangeSplitToggle;
        }, 900);
        
        // Path 2: hdfs → hadoop (file writes)
        setInterval(() => animatePacket(2), 1800);
        
        // Processor splits to Database and Events alternately
        setInterval(() => {
            if (processorSplitToggle) {
                animatePacket(4); // processor → database
            } else {
                animatePacket(5); // processor → vehicle_events
            }
            processorSplitToggle = !processorSplitToggle;
        }, 2400);

        // Path 6: hadoop → greenplum (analytics)
        setInterval(() => animatePacket(6), 4000);
        
        // Path 7: database → greenplum (processed data)
        setInterval(() => animatePacket(7), 3500);

        // Fetch metrics from API every 3 seconds
        setInterval(fetchMetrics, 3000);
        
        // Fetch exchange throughput every 2 seconds
        setInterval(fetchExchangeThroughput, 2000);
        
        // Fetch component health every 8 seconds (matches backend schedule)
        setInterval(fetchComponentHealth, 8000);
        
        // Fetch telemetry generator metrics every 5 seconds
        setInterval(fetchTelemetryMetrics, 5000);
        
        // Fetch exchange queue metrics every 6 seconds  
        setInterval(fetchExchangeQueueMetrics, 6000);
        
        // Fetch RabbitMQ health every 7 seconds
        setInterval(fetchRabbitMQHealth, 7000);
        
        // Fetch vehicle events metrics every 4 seconds  
        setInterval(fetchVehicleEventsMetrics, 4000);
        
        // Fetch events processor metrics every 5.5 seconds
        setInterval(fetchEventsProcessorMetrics, 5500);
        
        // Initial metrics fetch
        fetchMetrics();
        fetchExchangeThroughput();
        fetchComponentHealth();
        fetchTelemetryMetrics();
        fetchExchangeQueueMetrics();
        fetchRabbitMQHealth();
        fetchVehicleEventsMetrics();
        fetchEventsProcessorMetrics();
        fetchRabbitMQDashboardInfo();

    </script>
</body>
</html>
